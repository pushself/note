一、方法
	type Test struct {
		Name string
	}
	func (t Test) Show() {
	}

	var t = Test{"Name"}
调用方式：
	t.Show()//选择器语法来指定方法的接收器
	Show(t)//包级别函数（ 包名.Show(t) ）
	方法值：tt = t.Show //选择器，选择器会返回一个将方法(Point.Distance)绑定到特定接收器变量的函数
		tt()

	方法表达式：
		/*1*/
		show = Test.Show   //method expression  返回函数值
		Show(t)
		/×2×/
		var show func(t Test)
		show(t)
		


字段名跟方法名不能相同，否则编译器会报错。以上代码不能有Show命名的变量

type Path []Point
能够给任意类型定义方法（命名类型的底层类型不是指针或者interface），上面代码 Path就是命名类型，[]Point这个slice就是底层类型

方法只能在命名类型(像Point)或者指向类型的指针上定义

编译器根据接收器调用具体方法
	

1、附加参数t叫做方法的接收器
2、方法Show是类型Test独有的

二、基于指针对象的方法
	type Test struct {
		
	}
	func (t *Test) Show() {
	}
	var t = Test{}
	var p = &t
1、如何调用：用类型指针调用指针类型方法
2、接收器实际参数和形式参数不用的情况下：
	1、实参是类型T，形参是类型*T
		t.Show()//这种方式编译器会隐式的去获取变量t的地址  &t
	2、实参是类型*T，形参是类型T
		p.Show()//编译器自动解引用 *p
结论：不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换

3、只有类型(T)和指向他们的指针(*T)，才是可能会出现在接收器声明里的两种接收器。一个类型名本身是一个指针的话，是不允许其出现在接收器中的
	type P *int
	func (P) f(){}


不能通过一个无法取到地址的接收器来调用指针方法（临时变量的内存地址就无法获取）
Test{}.Show()//错误，非指针方法可以这样调用
	func (Test) Show() {}

type T struct{}
用类型T做接收器，这种情况下拷贝类型的实例是安全的，调用方法会产生值拷贝
type Test struct {
	name string
}

func (t Test) Show() {
	t.name = "show"
	fmt.Println(t.name)
}

func main() {
	var t = Test{"main"}
	t.Show()
	fmt.Println(t.name)
}
//输出
$:show
$:main
接收器t会进行值拷贝

Nil也是一个合法的接收器类型
例子1：
type Test struct {
	name string
}

type Test2 []string

func (t2 Test2) Show() {}

func (t Test) Show() {
	t.name = "show"
	fmt.Println(t.name)
}

func main() {
	var t Test
	t.Show()
	fmt.Println(t.name)
}
输出：
$:show
$:show

例子2：报错不能转换类型  答案：struct不支持nil  map slice可以支持nil方法
func main() {
	//错误
	var t Test
	t = nil
	t.Show()

	//错误
	var t2 Test2
	t2 = nil
	t2.Show()

	//正确
	t3 := Test2{"laoliao"}
	t3 = nil
	t3.Show() //等价与Test2(nil).Show() nil.Show()无法通过，nil的字面量编译器无法判断类型
	
}




虽然可以通过引用来操作内部值，但在方法想要修改引用本身是不会影响原始值的
type Test struct {
	name string
}

func (t *Test) Show() {
	t.name = "show"
	fmt.Println(t.name)
	t = nil
}

func main() {
	var t = Test{"main"}
	t.Show()
	fmt.Println(t.name)
}
输出：
$:show
$:show
个人理解：
	t是一个指针，t的地址为0x001  存储的内容为0x007
t.name = "Show"  操作的是t地址指向的实际数据，也就是地址0x007存储的实例
	t = nil 操作的是t本身，即0x001
	因为传入的是存储了内存地址的变量，你改变这个变量是影响不了原始的变量的



嵌入结构体来扩展类型
1、一个struct类型可以有多个匿名字段
2、如果有多个匿名字段，会现在当前类型中查找方法，然后按顺序到每一个匿名字段中查找

package main

import (
	"fmt"
)

type Point struct{ Name string }
type Point2 struct {
	Point
	Name2 string
}

func main() {
	var p Point2

	p.Name = "laoliao" //嵌入的字段就是Point2自身的字段
	p.Name2 = "laomei" 

	fmt.Println(p.Name)
	fmt.Println(p.Name2)
	//p.Show2(p)//不要把p看作是子类活着继承类  这是错误的理解
	p.Show2(p.Point) //跟下面注释代码等价

/*内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：*/

/*
func (p Point2) Show2(p2 Point) {
	p.Point.Show2(p2)
}
*/

//Point访问不到Point2的任何字段

}



封装：
	1、只有一种控制可见性的手段
		1.大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会
		2.限制包内成员的方式同样适用于struct或者一个类型的方法
	2、最小的封装单元是package（对象内部变量只可以被同一个包内的函数修改）
	3、一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。
	4、只用来访问或修改内部变量的函数被称为setter或者getter
	5、命名一个getter方法时，我们通常会省略掉前面的Get前缀
	6、一个对象的封装字段无法被该对象的方法以外的方法访问到

