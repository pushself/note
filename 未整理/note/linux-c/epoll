三、epoll 工作原理
3.1、在调用 epoll_create 之后，内核就已经创建了一个 eventpoll 红黑树结构体，一个 list 双向链表，在内核态准备接受存储需要监控的 fd。
3.2、在调用 epoll_ctr 之后，直接向内核态的 eventpoll 进行 add/mod/del 对应的 fd，对于新添加进来的 fd，重复的 fd 可以通过 eventpoll 红黑树识别出来，而不需要再次从用户态拷贝到内核态这个过程
3.3、同时 epoll 还维护了一个双向的 list 链表, 在epoll_ctr执行的时候，除了会向eventpoll 红黑树添加修改外，还会在内核中断函数处理程序中注册一个回调函数，告诉内核，当这个 fd 就绪之后，将他放到 list 里面去。
3.4、在 epoll_wait 调用的时候，就是观察这个双向 list 是否有数据，有就直接处理即可



5.1、没有 fd 数量限制，取决于系统内存的大小，一般来说 1GB 就可以有 10W个
5.2、内核和用户控件使用同一块内存，mmap技术，没有用户态和内核态之间的拷贝，提高效率
5.3、无需遍历所有，仅仅只需要遍历已经就绪的 fd 即可
