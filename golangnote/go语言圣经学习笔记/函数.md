###声明
```
func name(parameter-list) (result-list) {
    body
}
```
1. 返回值可以被命名 `被声明成局部变量，根据该返回值的类型，将其初始化为0`
2. 包含了返回值列表，函数体必须以"return"结尾
3. 一组形参或返回值具有相同类型，无需为每一个形参写明类型

```
func f(i, j, k int, s, t string)
func f(i int, j int, k int,  s string, t string)
```
4. 函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的
5. 函数的类型被称为函数的标识符
	* 两个函数形参列表和返回值列表中的变量类型一一对应，他们拥有相同的类型和标识符
	* 形参、返回值变量名不影响标识符，也不影响是否可以省略参数类型的形式表示
6. Go语言函数没有默认值
7. 形参是实参的拷贝，对形参的修改不会影响实参
	* 引用类型除外：slice、map、function、channel
8. 没有函数体的声明，表示该函数不是以Go实现。这样的声明定义了函数标识符
9. 函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中

#####4种方法声明
```
func add(x int, y int) int   {return x + y}
func sub(x, y int) (z int)   { z = x - y; return}
func first(x int, _ int) int { return x }  // _符号强调参数未被使用
func zero(int, int) int      { return 0 }

//输出
fmt.Printf("%T\n", add)
```

###多返回值
###函数递归
	1. 函数调用栈是动态的，按需增加。可以不用考虑递归时溢出和安全问题
	2. 其他编程语言函数调用栈是固定大小。64KB到2MB不等;限制递归深度，深层递归需避免栈溢出

###函数值
* Go中，函数被看作第一类值（first-class values)
* 函数拥有类型,复制给变量、传递给函数、从函数返回
* 函数类型的零值是nil,调用值为nil的函数值会引起panic错误  `示例2`
* 函数可以与nil比较,函数值之间是不可比较的，也不能用函数值作为map的key `示例3`

#####示例1：
```
func test(n int) int {return n}
func test2(m, n int) int {return n}

f := test
f(3)

t = test2 //t的类型是 func test(n int) int，而test2是func test2(int, int) int

```
#####示例2：
```
var t func(int) int

//panic: runtime error: invalid memory address or nil pointer dereference
f(3)
```
#####示例3：
```
var t func(int) int
var t2 func(int) int

if f != nil {
	f(3)
}


//invalid operation: t == t2 (func can only be compared to nil)
if t == t2 {
	fmt.Println("ok")
}


```

#####示例4：
```
type tt func(int)

func main() {
	var t tt
	t = Test
	t(4)
}

func Test(i int) {
	fmt.Println(i)
}
```
#####示例5：
```
type p func(string)

func main() {
	var pr p
	pr = Show
	Print("laoliao", pr)
}

func Show(str string) {
	fmt.Println(str)
}

func Print(str string, show func(string)) {
	show(str)
}
```

###问题
* 无名变量是什么
* 声明不包括返回值列表，函数体内却返回值。调用能否接收
* panic异常出现在return之前

###总结：
	1、f := "laoliao"   这种赋值方式编译器会推断"f"的类型为string;也就是说t的类型是string
	2、函数形参列表和返回值列表决定了函数类型