####接口
####接口值
* 组成
	* 类型 `接口动态类型`
		* 与之相关类型的描述符
	* 类型值 `接口动态值`
	> 一些提供每个类型信息的值被称为类型描述符 `类型的名称和方法`
* 接口值基于它的动态类型被描述为空或非空
* 接口值是可比较的：
	* 使用==和!=比较
	* 因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数
	* 两个接口值的动态类型相同，但是这个动态类型是不可比较的话会产生panic
	* 两个接口值相等
		* 类型和类型值都是nil值
		* 动态类型相同并且动态值也根据这个动态类型的＝＝操作相等
######示例1
```
//变量总是被一个定义明确的值初始化，接口类型也不例外
//接口的零值就是接口的类型和值部分都是nil

var w io.Writer
/*
type:nil
value:nil
1、这是一个空的接口值
2、w == nil判断接口是否为空，调用空接口值上任意方法都产生panic
*/

w = os.Stdout  //*os.File类型
fmt.Printf("%T\n", w) //*os.File
/*
赋值过程调用了一个具体类型到接口类型的隐式转换，等价与io.Writer(os.Stdout)
w的动态值是os.Stdout的拷贝
type:*os.File
*/
w.Write([]byte("hello"))   //(*os.File).Write
//os.Stdout.Write([]byte("hello"))  效果一样

w = new(bytes.Buffer)
/*
type:*bytes.Buffer
动态类型是*bytes.Buffer并且动态值是一个指向新分配的缓冲区的指针
调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址
*/
w = nil
```

######示例2
```
type Test1 interface {
	Show()
}
type Test2 struct {
	Name string
}

func (t Test2) Show() {
	t.Name = "shabi"
	fmt.Println(t.Name)
}
func main() {
	var t1 Test1
	var t2 = Test2{"laoliao"}
	var t3 *Test2

	t3 = &t2
	t1 = t3 

	t1.Show() //等价与(*t3).Show()
	/*
	type:*Test2
	value:指针，指向实际存储Test2类型（个人认为）
	*/
	
	//	t1 = t2
	//	t1.Show()

	fmt.Println(t2.Name)
}

```
####一个包含nil指针的接口不是nil接口
* 一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的
```
type Test1 interface {
	Show()
}
type Test2 struct {
	Name string
}

func (t Test2) Show() {
	fmt.Println("laoliao")
}

func main() {
	//	t1 := Test2{"hahaah"}
	var t2 *Test2 
	//t2是空指针，t的动态类型是*Test2   动态值是nil（t是包含空指针值的非空接口，所有t != nil。也就是从空指针上调用函数）
	//var t2 Test1  //避免一开始将一个不完全的值赋值给接口

	f(t2)
}

func f(t Test1) {
	if t != nil {
		t.Show()  //(*Test2).Show()  接收者是nil
		fmt.Print("not nil")
		return
	}
	fmt.Println("nil")
	return
}
```


##总结
* 接口变量只能调用接口类型中声明的字段?
* 接口类型变量可以接受任何实现了约束的类型变量以及类型指针 `示例2`


##临时记录
* interface{}被称为空接口类型，可以将任意一个值赋给空接口类型
* 接口只能约束方法
* 安全的可比较类型（如基本类型和指针）
* 完全不可比较的类型（如切片，映射类型，和函数）

##问题
	通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样：os.Stdout.Write([]byte("hello")) // "hello"


	这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为*os.Stdout指针的类型描述符，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的os.File类型变量的指针（图7.2）。
	
		但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。
	
		一个接口值可以持有任意大的动态值
		
		接口值调用接受者非空隐含先觉条件