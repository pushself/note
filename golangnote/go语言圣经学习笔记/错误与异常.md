####错误与异常
* 错误
	* 运行失败看做预期结果
	* 错误不同于异常
	* 内置error是接口类型
		* not-nil
		* nil
* 异常
	* 未预料到的错误
	* panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）
	* panic后程序崩溃并输出日志信息
		* panic value `某种错误信息`
		* 函数调用的堆栈跟踪信息 ``
	* panic会引起程序的崩溃，一般用于严重错误
	* runtime包允许程序员输出堆栈信息,利用延迟调用输出堆栈 `示例1`
	> runtime.Stack为何能输出已经被释放函数的信息？
	> Go的panic机制中，延迟函数的调用在释放堆栈信息之前
######示例1
```
func main() {
    defer printStack()
    f(3)
}
func printStack() {
    var buf [4096]byte
    n := runtime.Stack(buf[:], false)
    os.Stdout.Write(buf[:n])
}
```	
######示例2
```
//当调用者明确的知道正确的输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。我们应该假设函数的输入一直合法
package regexp
func Compile(expr string) (*Regexp, error) { /* ... */ }
func MustCompile(expr string) *Regexp {
    re, err := Compile(expr)
    if err != nil {
        panic(err)
    }
    return re
}

调用者知道输入正确的正则表达式不会引起错误，所以没有必要去检查Compile函数返回的错误，提供的MustCompile包装函数检查错误，抛出直接异常
```
		
####手动引发异常
```
panic()//接受任何值作为参数，参数就是panic value
```


####错误处理策略
* 传播错误，被调用函数的错误返回给调用函数
	* 错误信息中应避免大写和换行符
	* 相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的
```
data, err := Test()
if err != nil {
	return nil, err
}
```
* 偶然性的错误，或不可预知的问题导致，重新尝试失败的操作
* 输出错误信息并结束程序 `错误发生后程序无法继续运行` `os.Exit(1)`
	* 此策略只应在main中执行
	* 对库函数而言，应仅向上传播错误；除非该错误意味着程序内部包含不一致，即遇到了bug（个人：应该算异常），才能在库函数中结束程序
* 只输出错误信息，不中断程序的运行
	* 标准错误流输出错误信息
* 忽略错误
	* 该错误不会影响程序的逻辑


####Recover捕获异常
* 内置Recover函数使程序从异常中恢复
* 未发生panic时调用recover，recover会返回nil
* 不加区分的恢复所有的panic异常，不是可取的做法;因为在panic之后，无法保证包级变量的状态仍然和我们预期一致
> 比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放;引起一些资源泄漏
	* 安全的做法是选择性recover `示例4`
######示例3
```
func Parse(input string) (s *Syntax, err error) {
    defer func() {
    // p变量是panic value错误信息
        if p := recover(); p != nil {
            err = fmt.Errorf("internal error: %v", p)
        }
    }()
    // ...parser...
    //1、deferred函数中调用了内置函数recover，并且定义该defer语句的Parse函数发生了panic异常
    //2、recover使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回
    //3、原因是产生panic异常，defer语句依然会被执行
}
```
######示例4
>将panic value设置成特殊类型，在recover时对panic value检查
```
func main() {
	err := test("123")
	fmt.Println(err)
}

func test(str string) (err error) {
	type Test struct{}
	defer func() {
		switch p := recover(); p {
		case nil:
		case Test{}:
			err = fmt.Errorf("panic")
		default:
			panic(p)
		}
	}()

	//这是个错误的示范，任何可预料的错误应该以错误机制处理
	if str == "" {
		panic(Test{})
	}
	panic("return")
	return nil
}
```
####总结
* 通常将处理失败的逻辑代码放在处理成功的代码之前
* 某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中
* 任何可预料的错误，都应该使用go的错误机制
####问题
* 使用控制流机制（如if和return）处理异常，这使得编码人员能更多的关注错误处理。
* 未定义的返回值
* 断言函数跟panic什么关系   (switch)
* 函数名中的Must前缀是一种针对此类函数的命名约定，比如template.Must（4.6节）
* deferred函数
* defer函数中发生panic

####规范
不应该试图去恢复其他包引起的panic
公有的API应该将函数的运行失败作为error返回
也不应该恢复一个由他人开发的函数引起的panic
> 把对panic的处理都集中在一个包下，助于简化对复杂和不可以预料问题的处理;这条违反了释放规范