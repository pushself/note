####类型断言
* 使用在接口值上的操作
* 检查它`x`操作对象的动态类型是否和断言的类型匹配`T`
* 断言操作的对象不能为nil，否则都会断言失败
```
x.(T)
/*
x是接口类型
x是操作对象
T是一个具体的类型
对T进行类型断言？
T被断言
x是断言操作的对象
T是被断言的类型
*/
```
#####第一种情况 `具体类型的类型断言从它的操作对象中获得具体的值`
1. 断言的类型T是一个具体类型
2. 类型断言检查x的动态类型是否和T相同
3. 检查成功，类型断言的结果是x的动态值，既T`这句话没懂：具体类型的类型断言从它的操作对象中获得具体的值`
4. 如果检查失败，抛出panic



#####第二种情况 `对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合`
1. 断言类型T是一个接口类型
2. 类型断言检查变量x的动态类型是否==满足==T（意思就是x的动态类型是否实现了接口T）
3. 如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型T==这句话不理解什么意思==
```
type T1 interface {
	t1()
}
type T2 interface {
	t2()
}
type t struct {

}
type tt struct {

}
func (this t) t1(){

}
func (this t) t2() {

}
func (this tt) t1(){

}
type T3 interface {
	T1
	T2
}

	var test1 T1
	test1 = t{}
	a:=test1.(T3)//改变了可以获取的方法集合（通常更大）
	//test1开放t1方法，a开放t2方法
	/*
	理解：test1的动态类型=a的的动态类型，即t类型
	a类型是T3,a的动态类型是t
	*/
	a.t1()
	fmt.Printf("%T\n",a)
	
	//2
	test1 = new(tt)

	a=test1.(T3)//报错：interface conversion: *main.tt is not main.T3: missing method t2
	
	//3
	test1=a//test1类型是T1
	
	test1=a.(T1)//a==nil才会失败
```
#####类型断言在一个预期有两个结果的赋值操作
```
t,ok:=x.(T)
/*
1、这个操作不会发生panic
2、操作失败则ok==false
*/
```
#####类型断言的操作对象是一个变量
```
x, ok := x.(T)//重用的变量会覆盖原来的值
```

####记录
* 断言章节未阅读完毕
* 空接口不能断言？